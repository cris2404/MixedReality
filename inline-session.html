<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="favicon-96x96.png">
  <link rel="stylesheet" href="css/common.css">
  <title>Inline Session</title>
</head>

<body>
  <header>
    <details open>
      <summary>Inline Session</summary>
      <p>
        This sample demonstrates the use of an 'inline' XRSession to present content on the page prior to entering XR presentation with an immersive session. The viewer pose can be adjusted by clicking and dragging with mouse or touch.
        <a class="back" href="./">Back</a>
      </p>
      <p>
        <label for="vertFOV">Vertical FOV:</label>
        <input id="vertFOV" type="range" value="90" min="30" max="150" step="10" />
        <span id="vertFOVLabel">Vertical FOV: 90 degrees</span>
      </p>
    </details>
  </header>

  <script type="module">
    import { WebXRButton } from './js/util/webxr-button.js';
    import { Scene } from './js/render/scenes/scene.js';
    import { Renderer, createWebGLContext } from './js/render/core/renderer.js';
    import { Gltf2Node } from './js/render/nodes/gltf2.js';
    import { SkyboxNode } from './js/render/nodes/skybox.js';
    import { mat4, vec3, quat } from './js/render/math/gl-matrix.js';
    import { QueryArgs } from './js/util/query-args.js';
    import WebXRPolyfill from './js/third-party/webxr-polyfill/build/webxr-polyfill.module.js';

    if (QueryArgs.getBool('usePolyfill', true)) {
      new WebXRPolyfill();
    }

    const fov = document.getElementById('vertFOV');
    const fovLabel = document.getElementById('vertFOVLabel');

    function updateFov() {
      const value = parseFloat(fov.value);
      const radValue = value * (Math.PI / 180);

      if (inlineSession) {
        inlineSession.updateRenderState({ inlineVerticalFieldOfView: radValue });
      }

      fovLabel.textContent = `Vertical FOV: ${value} degrees${value === 90 ? ' (default)' : ''}`;
    }

    fov.addEventListener('input', updateFov);

    let inlineSession = null;
    let xrButton = null;
    let arButton = null;
    let arStarted = false;
    let gl = null;
    let renderer = null;
    const scene = new Scene();
    const solarSystem = new Gltf2Node({ url: 'media/gltf/space/space.gltf' });
    const skybox = new SkyboxNode({ url: 'media/textures/milky-way-4k.png' });
    scene.addNode(solarSystem);
    scene.addNode(skybox);

    function initXR() {
      xrButton = new WebXRButton({
        onRequestSession: onRequestVRSession,
        onEndSession: onEndSession,
      });
      document.querySelector('header').appendChild(xrButton.domElement);

      const lineBreak = document.createElement('br');
      document.querySelector('header').append(lineBreak, lineBreak.cloneNode());

      arButton = new WebXRButton({
        onRequestSession: onRequestARSession,
        onEndSession: onEndSession,
        textEnterXRTitle: 'START AR',
        textXRNotFoundTitle: 'AR NOT FOUND',
        textExitXRTitle: 'EXIT AR',
      });
      document.querySelector('header').appendChild(arButton.domElement);

      if (navigator.xr) {
        navigator.xr.isSessionSupported('immersive-vr').then((supported) => {
          xrButton.enabled = supported;
        });

        navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
          arButton.enabled = supported;
        });

        navigator.xr.requestSession('inline').then(onSessionStarted);
      }
    }

    function onRequestVRSession() {
      return navigator.xr.requestSession('immersive-vr').then((session) => {
        xrButton.setSession(session);
        session.isImmersive = true;
        onSessionStarted(session);
      });
    }

    function onRequestARSession() {
      return navigator.xr.requestSession('immersive-ar').then((session) => {
        arButton.setSession(session);
        session.isImmersive = true;
        arStarted = true;
        onSessionStarted(session);
      });
    }

    function onSessionStarted(session) {
      session.addEventListener('end', onSessionEnded);

      if (!gl) {
        gl = createWebGLContext({ xrCompatible: true });
        document.body.appendChild(gl.canvas);

        function onResize() {
          gl.canvas.width = gl.canvas.clientWidth * window.devicePixelRatio;
          gl.canvas.height = gl.canvas.clientHeight * window.devicePixelRatio;
        }
        window.addEventListener('resize', onResize);
        onResize();

        addInlineViewListeners(gl.canvas);

        renderer = new Renderer(gl);
        scene.setRenderer(renderer);
      }

      const glLayer = new XRWebGLLayer(session, gl);
      session.updateRenderState({ baseLayer: glLayer });

      const refSpaceType = session.isImmersive ? 'local' : 'viewer';
      session.requestReferenceSpace(refSpaceType).then((refSpace) => {
        if (session.isImmersive) {
          xrImmersiveRefSpace = refSpace;
          if (arStarted) skybox.visible = false;
        } else {
          xrInlineRefSpace = refSpace;
        }
        session.requestAnimationFrame(onXRFrame);
      });
    }

    function onEndSession(session) {
      session.end();
    }

    function onSessionEnded(event) {
      if (event.session.isImmersive) {
        xrButton.setSession(null);
        if (arStarted) {
          arButton.setSession(null);
          arStarted = false;
          skybox.visible = true;
        }
      }
    }

    function onXRFrame(t, frame) {
      const session = frame.session;
      const refSpace = session.isImmersive ? xrImmersiveRefSpace : getAdjustedRefSpace(xrInlineRefSpace);
      const pose = frame.getViewerPose(refSpace);

      scene.startFrame();
      session.requestAnimationFrame(onXRFrame);

      if (pose) {
        const glLayer = session.renderState.baseLayer;
        gl.bindFramebuffer(gl.FRAMEBUFFER, glLayer.framebuffer);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        pose.views.forEach((view) => {
          const viewport = glLayer.getViewport(view);
          gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);
          scene.draw(view.projectionMatrix, view.transform);
        });
      }

      scene.endFrame();
    }

    initXR();
  </script>
</body>

</html>
